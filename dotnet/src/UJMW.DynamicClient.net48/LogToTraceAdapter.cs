
//-----------------------------------------------------------------------
//<auto-generated>
// THIS CODE IS AN AUTOMATIC MIRROR OF:
// https://raw.githubusercontent.com/SmartStandards/Logging/master/dotnet/src/Logging/Logging/SmartStandards/LogToTraceAdapter.cs
// Project: https://github.com/SmartStandards/Logging(thanks to the autor!)
//</auto-generated>
//-----------------------------------------------------------------------

using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;
using System;
using System.Security.Cryptography;
using System.Reflection;
using System.ComponentModel;
using System.Text;
using System.IO;
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace Logging.SmartStandards {

  internal partial class LogToTraceAdapter {

    private static Dictionary<string, TraceSource> _TraceSourcePerAudienceToken = new Dictionary<string, TraceSource>();

    private static TraceSource GetTraceSourcePerAudienceName(string audience) {

      TraceSource traceSource;

      lock (_TraceSourcePerAudienceToken) {
        if (!_TraceSourcePerAudienceToken.TryGetValue(audience, out traceSource)) { // Lazily wire up the trace source...

          // ... but ensure the desired listener was initialized before:

          bool found = false;

          foreach (TraceListener l in Trace.Listeners) {
            if (l.GetType().Name.EndsWith("TraceLogPipe")) { // convention!
              found = true;
              break;
            }
          }

          if (!found) return null;

          // actual wire-up

          traceSource = new TraceSource(audience);
          traceSource.Switch.Level = SourceLevels.All;
          traceSource.Listeners.Clear(); // Otherwise the default listener will be registered twice
          traceSource.Listeners.AddRange(Trace.Listeners); // Wire up all CURRENTLY existing trace listeners (they have to be initialized before!)

          _TraceSourcePerAudienceToken[audience] = traceSource;

        }
      }

      return traceSource;
    }

    internal static void LogToTrace(string audience, int level, int id, string messageTemplate, params object[] args) {

      TraceSource traceSource = GetTraceSourcePerAudienceName(audience);

      if (traceSource is null) return;

      TraceEventType eventType;

      switch (level) {

        case 5: { // Critical (aka "Fatal")
            eventType = TraceEventType.Critical; // 1
            break;
          }

        case 4: { // Error
            eventType = TraceEventType.Error; // 2
            break;
          }

        case 3: { // Warning
            eventType = TraceEventType.Warning; // 4
            break;
          }

        case 2: { // Info
            eventType = TraceEventType.Information; // 8
            break;
          }

        case 1: { // Debug
            eventType = TraceEventType.Transfer; // 4096 - ' There is no "Debug" EventType => use something else
                                                 // 0 "Trace" (aka "Verbose")
            break;
          }

        default: {
            eventType = TraceEventType.Verbose; // 16
            break;
          }

      }

      // Because we support named placeholders (like "Hello {audience}") instead of old scool indexed place holders (like "Hello {0}")
      // we need to double brace the placeholders - otherwise there will be exceptions coming from the .net TraceEvent Method.

      string formatString = messageTemplate?.Replace("{", "{{").Replace("}", "}}");

      traceSource.TraceEvent(eventType, id, formatString, args);
    }

  }

}
namespace Logging.SmartStandards {

  internal static partial class ExceptionSerializer {

    /// <summary>
    /// Serializes an Exception in a way, that InnerExceptions and StackTraces are included
    /// and returns a message string, which is highly optimized for logging requirements.
    /// </summary>
    /// <param name="ex"></param>
    /// <param name="includeStacktrace"></param>
    /// <returns></returns>
    internal static string Serialize(this Exception ex, bool includeStacktrace = true) {
      StringBuilder sb = new StringBuilder(1000);
      string messageMainLine = ex.Message;
      AppendRecursive(ex, sb, ref messageMainLine, includeStacktrace);
      sb.Insert(0, messageMainLine + Environment.NewLine);
      return sb.ToString();
    }

    private static void AppendRecursive(Exception ex, StringBuilder target, ref string messageMainLine, bool includeStacktrace, bool isInner = false) {

      if (ex == null) {
        return;
      }

      target.Append($"__{ex.GetType().FullName}__");
      if (isInner) {
        target.Append($" (inner)");
      }

      if (includeStacktrace && !string.IsNullOrWhiteSpace(ex.StackTrace)) {
        var tr = new StringReader(ex.StackTrace);
        string currentStacktraceLine = tr.ReadLine()?.Trim();
        while (currentStacktraceLine != null) {
          target.AppendLine();
          target.Append("@   ");
          target.Append(currentStacktraceLine.Replace(" in ", Environment.NewLine + "@   "));
          currentStacktraceLine = tr.ReadLine()?.Trim();
        }
      }

      if ((ex.InnerException != null)) {
        messageMainLine = messageMainLine + " >> " + ex.InnerException.Message;
        target.AppendLine();
        AppendRecursive(ex.InnerException, target, ref messageMainLine, includeStacktrace, true);
      }

    }

    internal static int GetGenericIdFromException(Exception ex) {
      if (ex is TargetInvocationException && ex.InnerException != null) {
        return GetGenericIdFromException(ex.InnerException);
      }
      if (ex is Win32Exception) {
        return ((Win32Exception)ex).NativeErrorCode;
      }
      int hashTagIndex = ex.Message.LastIndexOf("#");
      if (hashTagIndex >= 0 && int.TryParse(ex.Message.Substring(hashTagIndex + 1), out int id)) {
        return id;
      }
      else {
        using (var md5 = MD5.Create()) {
          int hash = BitConverter.ToInt32(md5.ComputeHash(Encoding.UTF8.GetBytes(ex.GetType().Name)), 0);
          if (hash < 0) {
            return hash * -1;
          }
          return hash;
        }
      }
    }
  }

}


///////////////////// HERE STARTS OWN ADDITIONAL CODE (can be maintained in the .tt file!) /////////////////////////

namespace Logging.SmartStandards {

  /// <summary>
  /// A simple version of the SmartStandards DevLogger,
  /// which has only one hardcoded logging target writing into the
  /// Windows-Tracing (completely decoupled from, but collectable by
  /// the SmartStandards.Logging library)
  /// </summary>
  partial class DevToTraceLogger {

    private static string _LibPrefix = "(" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Name + ") ";

    public static void LogCritical(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogCritical(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }
    public static void LogCritical(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogError(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogError(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }
    public static void LogError(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogWarning(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogWarning(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }
    public static void LogWarning(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogInformation(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogInformation(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }
    public static void LogInformation(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogDebug(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogDebug(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }
    public static void LogDebug(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogTrace(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogTrace(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }
    public static void LogTrace(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

  }

}
