<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 
// THIS T4 TEMPLATE DOWNLOADs SOURCECODE VIA HTTP AND GENERATES A FILE FROM IT... (by T.Korn - 21.09.2018)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CONFIG:                                                                                                                 //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    string fileDownloadUrl = "https://raw.githubusercontent.com/SmartStandards/Logging/master/dotnet/src/Logging/Logging/SmartStandards/LogToTraceAdapter.cs";
    string fileDownloadUrl2 = "https://raw.githubusercontent.com/SmartStandards/Logging/master/dotnet/src/Logging/Logging/SmartStandards/ExceptionSerializer.cs";
      
    string projectUrl = "https://github.com/SmartStandards/Logging";

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    string content = "//-----------------------------------------------------------------------\n//<auto-generated>\n// THIS CODE IS AN AUTOMATIC MIRROR OF:\n// " + fileDownloadUrl + "\n// Project: " + projectUrl + "(thanks to the autor!)\n//</auto-generated>\n//-----------------------------------------------------------------------\n\n{usings}\n";
    try {
      using (var wc = new System.Net.WebClient()) {
        content = content + wc.DownloadString(fileDownloadUrl);
      }
      using (var wc = new System.Net.WebClient()) {
        string file2 = wc.DownloadString(fileDownloadUrl2);
        content = content + file2.Substring(file2.IndexOf("namespace"));
      }
      string sourceInfo = "Mirrored file from GitHub";
      string vers = DateTime.Now.ToShortDateString();

      content = EnsureUsing(content, "System.CodeDom.Compiler");
      content = EnsureUsing(content, "System.Runtime.CompilerServices");

      content = content.Replace("{usings}\n","using System;\nusing System.Security.Cryptography;\nusing System.Reflection;\nusing System.ComponentModel;\nusing System.Text;\nusing System.IO;\n");

      string compilerGeneratedAttributes = "[CompilerGeneratedAttribute()][GeneratedCode( tool:\"" + sourceInfo + "\", version:\"" + vers + "\")]";

      content = content.Replace("public class",     compilerGeneratedAttributes + "\n    internal class");
      content = content.Replace("public interface", compilerGeneratedAttributes + "\n    internal interface");
      content = content.Replace("public enum",      compilerGeneratedAttributes + "\n    internal enum");
      content = content.Replace("class ", "partial class ");
    }
    catch (Exception ex) {
      content = "Cannot download '" + fileDownloadUrl  + "': " + ex.Message;
    }
///////////////////// HERE STARTS CUSTOM PATCHING //////////////////////////////////////////////////////////////////


  content = content.Replace("public ", "internal ");


///////////////////// HERE  CUSTOM PATCHING ////////////////////////////////////////////////////////////////////////
#>

<#= content #>

///////////////////// HERE STARTS OWN ADDITIONAL CODE (can be maintained in the .tt file!) /////////////////////////

namespace Logging.SmartStandards {

  /// <summary>
  /// A simple version of the SmartStandards DevLogger,
  /// which has only one hardcoded logging target writing into the
  /// Windows-Tracing (completely decoupled from, but collectable by
  /// the SmartStandards.Logging library)
  /// </summary>
  partial class DevToTraceLogger {

    private static string _LibPrefix = "(" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Name + ") ";
    
    public static void LogCritical(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogCritical(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogCritical(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogError(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogError(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogError(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogWarning(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogWarning(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogWarning(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogInformation(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogInformation(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogInformation(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogDebug(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogDebug(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogDebug(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogTrace(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogTrace(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogTrace(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

  }

 }
<#+ 
///////////////////// HERE ENDS OWN ADDITIONAL CODE ///////////////////////////////////////////////////////////////
  string EnsureUsing(string content, string ns){  
    if(!content.Contains("using " + ns + ";")){
      content = content.Replace("{usings}\n","using " + ns + ";\n{usings}\n");    
    }
    return content;
  }
#>