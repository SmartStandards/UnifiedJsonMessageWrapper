
//-----------------------------------------------------------------------
//<auto-generated>
// THIS CODE IS AN AUTOMATIC MIRROR OF:
// https://raw.githubusercontent.com/SmartStandards/Logging/master/dotnet/src/Logging/Logging/SmartStandards/LogToTraceAdapter.cs
// Project: https://github.com/SmartStandards/Logging(thanks to the autor!)
//</auto-generated>
//-----------------------------------------------------------------------

using System.CodeDom.Compiler;
using System.Runtime.CompilerServices;
using System;
using System.Security.Cryptography;
using System.Reflection;
using System.ComponentModel;
using System.Text;
using System.IO;
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace Logging.SmartStandards {

  internal partial class LogToTraceAdapter {

    private static Dictionary<string, TraceSource> _TraceSourcePerChannelName;

    private static TraceSource GetTraceSourcePerChannelName(string channelName) {

      if (_TraceSourcePerChannelName is null) _TraceSourcePerChannelName = new Dictionary<string, TraceSource>();

      TraceSource traceSource;

      if (!_TraceSourcePerChannelName.TryGetValue(channelName, out traceSource)) { // Lazily wire up the trace source...

        // ... but ensure the desired listener was initialized before:

        bool found = false;

        foreach (TraceListener l in Trace.Listeners) {
          if (l.GetType().Name.EndsWith("TraceLogPipe")) { // convention!
            found = true;
            break;
          }
        }

        if (!found) return null;

        // actual wire-up

        traceSource = new TraceSource(channelName);
        traceSource.Switch.Level = SourceLevels.All;
        traceSource.Listeners.Clear(); // Otherwise the default listener will be registered twice
        traceSource.Listeners.AddRange(Trace.Listeners); // Wire up all CURRENTLY existing trace listeners (they have to be initialized before!)

        _TraceSourcePerChannelName[channelName] = traceSource;

      }
      return traceSource;
    }

    internal static void LogToTrace(string channelName, int level, int id, string messageTemplate, params object[] args) {

      TraceSource traceSource = GetTraceSourcePerChannelName(channelName);

      if (traceSource is null) return;

      TraceEventType eventType;

      switch (level) {

        case 5: { // Critical (aka "Fatal")
          eventType = TraceEventType.Critical; // 1
          break;
        }

        case 4: { // Error
          eventType = TraceEventType.Error; // 2
          break;
        }

        case 3: { // Warning
          eventType = TraceEventType.Warning; // 4
          break;
        }

        case 2: { // Info
          eventType = TraceEventType.Information; // 8
          break;
        }

        case 1: { // Debug
          eventType = TraceEventType.Transfer; // 4096 - ' There is no "Debug" EventType => use something else
                                               // 0 "Trace" (aka "Verbose")
          break;
        }

        default: {
          eventType = TraceEventType.Verbose; // 16
          break;
        }

      }

      // Because we support named placeholders (like "Hello {audience}") instead of old scool indexed place holders (like "Hello {0}")
      // we need to double brace the placeholders - otherwise there will be exceptions coming from the .net TraceEvent Method.

      string formatString = messageTemplate?.Replace("{", "{{").Replace("}", "}}");

      traceSource.TraceEvent(eventType, id, formatString, args);
    }

  }

}
namespace Logging.SmartStandards {

  internal static partial class ExceptionSerializer {

    /// <summary>
    /// Serializes an Exception in a way, that InnerExceptions and StackTraces are included
    /// and returns a message string, which is highly optimized for logging requirements.
    /// </summary>
    /// <param name="ex"></param>
    /// <param name="includeStacktrace"></param>
    /// <returns></returns>
    internal static string Serialize(this Exception ex, bool includeStacktrace = true) {
      StringBuilder sb = new StringBuilder(1000);
      string messageMainLine = ex.Message ;
      AppendRecursive(ex, sb, ref messageMainLine, includeStacktrace);
      sb.Insert(0, messageMainLine + Environment.NewLine);
      return sb.ToString();
    }

    private static void AppendRecursive(Exception ex, StringBuilder target, ref string messageMainLine, bool includeStacktrace, bool isInner = false) {
     
      if (ex == null) {
        return;
      }

      target.Append($"__{ex.GetType().FullName}__");
      if (isInner) {
        target.Append($" (inner)");
      }

      if (includeStacktrace && !string.IsNullOrWhiteSpace(ex.StackTrace)) {
          var tr = new StringReader(ex.StackTrace);
          string currentStacktraceLine = tr.ReadLine()?.Trim();
          while (currentStacktraceLine != null) {
          target.AppendLine();
          target.Append("@   ");
          target.Append(currentStacktraceLine.Replace(" in ", Environment.NewLine + "@   "));
          currentStacktraceLine = tr.ReadLine()?.Trim();
        }
      }

      if ((ex.InnerException != null)) {
        messageMainLine = messageMainLine + " >> " + ex.InnerException.Message;
        target.AppendLine();
        AppendRecursive( ex.InnerException,target, ref messageMainLine, includeStacktrace, true);
      }

    }

    internal static int GetGenericIdFromException(Exception ex) {
      if (ex is TargetInvocationException && ex.InnerException != null) {
        return GetGenericIdFromException(ex.InnerException);
      }
      if (ex is Win32Exception) {
        return ((Win32Exception)ex).NativeErrorCode;
      }
      int hashTagIndex = ex.Message.LastIndexOf("#");
      if (hashTagIndex >= 0 && int.TryParse(ex.Message.Substring(hashTagIndex+1), out int id)) {
        return id;
      }
      else {
        using (var md5 = MD5.Create()) {
          int hash = BitConverter.ToInt32(md5.ComputeHash(Encoding.UTF8.GetBytes(ex.GetType().Name)), 0);
          if(hash < 0) {
            return hash * -1;
          }
         return hash;
        }
      }
    }
  }

}


///////////////////// HERE STARTS OWN ADDITIONAL CODE (can be maintained in the .tt file!) /////////////////////////

namespace Logging.SmartStandards {

  /// <summary>
  /// A simple version of the SmartStandards DevLogger,
  /// which has only one hardcoded logging target writing into the
  /// Windows-Tracing (completely decoupled from, but collectable by
  /// the SmartStandards.Logging library)
  /// </summary>
  partial class DevToTraceLogger {

    private static string _LibPrefix = "(" + System.Reflection.Assembly.GetExecutingAssembly().GetName().Name + ") ";
    
    public static void LogCritical(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogCritical(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogCritical(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 5, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogError(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogError(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogError(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 4, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogWarning(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogWarning(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogWarning(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 3, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogInformation(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogInformation(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogInformation(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 2, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogDebug(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogDebug(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogDebug(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 1, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

    public static void LogTrace(int id, string messageTemplate, params object[] args) {
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + messageTemplate, args);
    }
    public static void LogTrace(int id, System.Exception ex) {
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + ex.Serialize(), new object[] {ex});
    }
    public static void LogTrace(System.Exception ex) {
      int id = ExceptionSerializer.GetGenericIdFromException(ex);
      LogToTraceAdapter.LogToTrace("Dev", 0, id, _LibPrefix + ex.Serialize(), new object[] { ex });
    }

  }

 }
