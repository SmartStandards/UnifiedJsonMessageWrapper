using Microsoft.Extensions.Options;
using System.Collections.Generic;
using System.Linq;

namespace System.Web.UJMW {

  public class DynamicUjmwControllerOptions {

    /// <summary>
    /// Use this to custimize the route of your Endpoint.
    /// Therefore you can use Placeholders:
    /// {0} {1} {...} to address type-names from generic arguments, 
    /// '{Controller}' for the controller name (repecting the 'ControllerNamePattern') or
    /// '[Controller]' for the original controller name)
    /// </summary>
    public string ControllerRoute { get; set; } = null;

    /// <summary>
    /// Use this to custimize the Title of your Endpoint (as shown in Swagger).
    /// Therefore you can use Placeholders:
    /// {0} {1} {...} to address type-names from generic arguments, 
    /// '{Controller}' for the controller name (repecting the 'ControllerNamePattern') or
    /// '[Controller]' for the original controller name)
    /// </summary>
    public string ControllerTitle { get; set; } = null;

    /// <summary>
    /// Use this to discriminate the name of your controller and autogenerated ujmw-dtos to
    /// resolve collisions by duplicate controller-names and/or method-names.
    /// Therefore you can use Placeholders:
    /// {0} {1} {...} to address type-names from generic arguments, 
    /// '{Controller}' for the controller name (repecting the 'ControllerNamePattern') or
    /// '[Controller]' for the original controller name)
    /// </summary>
    [Obsolete("The 'ClassNameDiscriminator' affects the controller class name and wrapper class names in the same way - this is deprecated! Please use 'ControllerNamePattern' and/or 'WrapperNamePattern' instead!")]
    public string ClassNameDiscriminator { get; set; } = null;

    /// <summary>
    /// Use this to discriminate the name of your controller to resolve collisions by duplicate controller-names.
    /// Therefore you can use Placeholders:
    /// {0} {1} {...} to address type-names from generic arguments, 
    /// '{Controller}' for the controller name (repecting the 'ControllerNamePattern') or
    /// '[Controller]' for the original controller name)
    /// </summary>
    public string ControllerNamePattern { get; set; } = null;

    /// <summary>
    /// Use this to discriminate the name of your request-/response-wrapper classes to
    /// resolve collisions by duplicate method-names comming from multiple controllers.
    /// Therefore you can use Placeholders:
    /// {0} {1} {...} to address type-names from generic arguments, 
    /// '{Controller}' for the controller name (repecting the 'ControllerNamePattern') or
    /// '[Controller]' for the original controller name) or
    /// '[Method]' for the Method-Name
    /// </summary>
    public string WrapperNamePattern { get; set; } = null;

    /// <summary> build the '_' property within the json message wrapper of requests to transport ambient information </summary>
    public bool EnableRequestSidechannel { get; set; } = true;

    /// <summary> build the '_' property within the json message wrapper of responses to transport ambient information </summary>
    public bool EnableResponseSidechannel { get; set; } = true;

    /// <summary>
    /// When true, an 'IAsyncActionFilter' will be applied to the dynamic controller internally,
    /// to redirect the Http-Authorization headers to the 'UjmwHostConfiguration.AuthHeaderEvaluator'-Method.
    /// You can set this to false to increase performance, if no authorization is needed or is applied in another way.
    /// </summary>
    public bool EnableAuthHeaderEvaluatorHook { get; set; } = true;

    /// <summary>
    /// If enabled, any user can access the controller via http-GET (without authentication) and will see an info-site.
    /// </summary>
    public bool EnableInfoSite { get; set; } = true;

    public Type AuthAttribute { get; set; } = null;
    public object[] AuthAttributeConstructorParams { get; set; } = new object[] { };

    #region " Contextualization "

    /// <summary>
    ///  Registers an argument, which will be provided contextually during each call of this endpoint.
    ///  The value (provided by the given valueGetter) will be served to
    ///   the IncommingRequestSideChannel-Hooks (UjmwHostConfiguration)
    ///   and to the ContextualizationHook (DynamicUjmwControllerOptions) individually for this endpoint.
    /// </summary>
    /// <param name="name">Internal addressable name of the argument to be registerd.</param>
    /// <param name="valueGetter">A method which provides the value on-demand.</param>
    public void BindContextualArgument(string name, Func<string> valueGetter) {
      this.ContextualArgumentNameCollissionGuard(name);
      _ContextualGetterBasedArguments[name] = valueGetter;
    }
    private Dictionary<string, Func<string>> _ContextualGetterBasedArguments = new Dictionary<string, Func<string>>();

    /// <summary>
    ///  Registers an argument, which will be provided contextually during each call of this endpoint.
    ///  The value (dynamically picked from the controllers url/route) will be served to
    ///   the IncommingRequestSideChannel-Hooks (UjmwHostConfiguration)
    ///   and to the ContextualizationHook (DynamicUjmwControllerOptions) individually for this endpoint.
    /// </summary>
    /// <param name="name">Internal addressable name of the argument to be registerd.</param>
    /// <param name="routeSegmentAlias">
    ///   An optional alias for the route segment, wich is more relevant for documentation (Swagger, etc.).
    /// </param>
    public void BindContextualArgumentToRouteSegment(string name, string routeSegmentAlias = null) {
      this.ContextualArgumentNameCollissionGuard(name);
      _ContextualRouteSegmentArguments[name] = routeSegmentAlias ?? name;
    }
    internal Dictionary<string, string> _ContextualRouteSegmentArguments = new Dictionary<string, string>();

    /// <summary>
    ///  Registers an argument, which will be provided contextually during each call of this endpoint.
    ///  The value (dynamically picked from the incomming request-header) will be served to
    ///   the IncommingRequestSideChannel-Hooks (UjmwHostConfiguration)
    ///   and to the ContextualizationHook (DynamicUjmwControllerOptions) individually for this endpoint.
    /// </summary>
    /// <param name="name">Internal addressable name of the argument to be registerd.</param>
    /// <param name="headerName">Name/Key of the request-header to pick the value from.</param>
    public void BindContextualArgumentToHeaderValue(string name, string headerName) {
      this.ContextualArgumentNameCollissionGuard(name);
      _ContextualHeaderValueArguments[name] = headerName;
    }
    private Dictionary<string,string> _ContextualHeaderValueArguments = new Dictionary<string, string>();

    private void ContextualArgumentNameCollissionGuard(string name) {
      if (_ContextualGetterBasedArguments.ContainsKey(name)) {
        throw new ArgumentException($"The contextual argument with name '{name}' was already registered as Getter-Based Argument!");
      }
      if (_ContextualRouteSegmentArguments.ContainsKey(name)) {
        throw new ArgumentException($"The contextual argument with name '{name}' was already registered as Route-Segment-Based Argument!");
      }
      if (_ContextualHeaderValueArguments.ContainsKey(name)) {
        throw new ArgumentException($"The contextual argument with name '{name}' was already registered as Header-Value-Based Argument!");
      }
    }

    internal IDictionary<string,Func<string>> GetUniformedContextualArgumentGetters(
      Func<string,string> headerValueGetter,
      Func<string,string> routeValueGetter
    ) {
      Dictionary<string, Func<string>> combined = new Dictionary<string, Func<string>>();
      lock (_ContextualGetterBasedArguments) {
        foreach (var kvp in _ContextualGetterBasedArguments) {
          combined[kvp.Key] = kvp.Value;
        }
      }
      lock (_ContextualHeaderValueArguments) {
        foreach (var kvp in _ContextualHeaderValueArguments) {
          string headerName = kvp.Value;
          combined[kvp.Key] = () => headerValueGetter(headerName);
        }
      }
      lock (_ContextualRouteSegmentArguments) {
        foreach (var kvp in _ContextualRouteSegmentArguments) {
          string routeSegmentName = kvp.Value;
          combined[kvp.Key] = () => routeValueGetter(routeSegmentName);
        }
      }
      return combined;
    }

    /// <summary>
    /// A Method, which will be invoked around each call of this endpoint,
    /// to enrich the contextual information available during the call, like entering a logical call-context / 
    /// transaction-/tenancy-scopes.
    /// The hook will be able to access the individual contextual arguments as registered by using the
    /// BindContextualArgument... -Methods (also provided by this class).
    /// NOTE: Please see also the 'IncommingRequestSideChannel'-Hooks (UjmwHostConfiguration)
    /// which globally (not dedicated to a single endpoint) providing similar functionality.
    /// This Hook might be prefferred before doing this indivudually here.
    /// </summary>
    public ContextualizationHookDelegate ContextualizationHook { get; set; } = null;

    /// <summary>
    /// A Method, which will be invoked around each call of this endpoint,
    /// to enrich the contextual information available during the call, like entering a logical call-context / 
    /// transaction-/tenancy-scopes.
    /// The hook will be able to access the individual contextual arguments as registered by using the
    /// BindContextualArgument... -Methods (also provided by this class).
    /// NOTE: Please see also the 'IncommingRequestSideChannel'-Hooks (UjmwHostConfiguration)
    /// which globally (not dedicated to a single endpoint) providing similar functionality.
    /// This Hook might be prefferred before doing this indivudually here.
    /// </summary>
    /// <param name="endpointContextualArguments"></param>
    /// <param name="innerInvokeContextual">
    ///   The 'vanilla' method of the service which MUST be invoked while the current call is running contextualized.
    /// </param>
    public delegate void ContextualizationHookDelegate(
      IDictionary<string, string> endpointContextualArguments,
      Action innerInvokeContextual
    );

    #endregion

  }

}
