<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<# 

// This template allows to use logging (into .NET trace) in SmartStandards compliant manner without using NuGet 
// packages.
// Sources will directly be downloaded from git and aggregated into one monolithic .cs file.

string ttVersion = "2.1.0"; // (compatible with SmartStandards.Logging 3.2.2)

bool ttVersionCheck = true;

string projectUrl = "https://github.com/SmartStandards/Logging";

string repositoryRootUrl = "https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/";

string fileDownloadSourceDirectroy = "dotnet/src/SmartStandards.Logging/";

string ttLocation = "dotnet/test/SmartStandards.Logging.ThirdPartyTests/SmartStandards.Logging.tt";

string[] fileDownloadUrls = new string[] {

  "Logging/SmartStandards/Textualization/CopyOfPlaceholderExtensions .cs",
  "Logging/SmartStandards/Textualization/LogParaphRenderer.Minimum.cs",
  "Logging/SmartStandards/Textualization/ExceptionRenderer.cs",
  "Logging/SmartStandards/Transport/TraceBusFeed.cs",
  "Logging/SmartStandards/Transport/TraceBusFeed.Buffer.cs",

  "Logging/SmartStandards/Internal/ExceptionAnalyzer.cs",
  "Logging/SmartStandards/Internal/SourceContextDiscoverer.cs",

  "Logging/SmartStandards/BizLogger.cs",
  "Logging/SmartStandards/BizLogger.PerLevel.cs",
  "Logging/SmartStandards/BizLogger.WoSourceContext.cs",
  
  "Logging/SmartStandards/DevLogger.cs",
  "Logging/SmartStandards/DevLogger.PerLevel.cs",
  "Logging/SmartStandards/DevLogger.WoSourceContext.cs",

  "Logging/SmartStandards/InsLogger.cs",
  "Logging/SmartStandards/InsLogger.PerLevel.cs",
  "Logging/SmartStandards/InsLogger.WoSourceContext.cs",

  "Logging/SmartStandards/SecLogger.cs",
  "Logging/SmartStandards/SecLogger.PerLevel.cs",
  "Logging/SmartStandards/SecLogger.WoSourceContext.cs",

  "Logging/SmartStandards/ExceptionExtensions.cs",
  
  "Logging/SmartStandards/EventKindManagement/LogMessageTemplateAttribute.cs",
  "Logging/SmartStandards/EventKindManagement/EventKindEnumConverter.cs",
  "Logging/SmartStandards/EventKindManagement/EventKindRepository.cs",
   
};

string content;

string currentFileUrl = "";

try {

  StringBuilder aggregatedContent = new StringBuilder(10000);

  List<string> usings = new List<string>();

  aggregatedContent.AppendLine();
  aggregatedContent.AppendLine("// This is a partial copy of the SmartStandards Logging Library.");
  aggregatedContent.AppendLine("// It is intended to be used as an alternative when including the NuGet package is not feasible.");
  aggregatedContent.AppendLine("// It offers reduced features: There is no custom routing, emitted log events always flow to the TraceBus.");
  aggregatedContent.AppendLine();
  aggregatedContent.Append("// This file was generated by SmartStandards.Logging.tt v ");
  aggregatedContent.AppendLine(ttVersion);
  aggregatedContent.Append("// Included sources were downloaded from: ");
  aggregatedContent.AppendLine(projectUrl);

  using (var wc = new System.Net.WebClient()) {

    if (ttVersionCheck) {
      string t4ContentAtOrigin = wc.DownloadString(repositoryRootUrl + ttLocation);
      string t4VersionAtOrigin = "unknown";
      var match = System.Text.RegularExpressions.Regex.Match(t4ContentAtOrigin, @"string\s+ttVersion\s*=\s*""([\d\.]+)""");
      if (match.Success) {
        t4VersionAtOrigin = match.Groups[1].Value;
        Version latestVersion = new Version(t4VersionAtOrigin);
        Version currentVersion = new Version(ttVersion);
        if (currentVersion < latestVersion) {
          string errMsg = "Your copy of this T4-Template has an old Version (" + ttVersion + " instead of " + t4VersionAtOrigin + ")!";
          this.Error(errMsg);   
          return "//" + errMsg + "\n//Please download it again from here:\n//" + repositoryRootUrl + ttLocation + "\n//or set 'ttVersionCheck = false'";
        }
      }
      else {
          string errMsg = "Could not determine ttVersion from origin file: " + repositoryRootUrl + ttLocation;
          this.Error(errMsg);   
          return "//" + errMsg;
      }
    }

    foreach (string fileDownloadUrl in fileDownloadUrls) {

      currentFileUrl = repositoryRootUrl + fileDownloadSourceDirectroy + fileDownloadUrl;

      string fileContent = wc.DownloadString(currentFileUrl);

      using (TextReader reader = new StringReader(fileContent)) {

        string currentLine = reader.ReadLine();

        aggregatedContent.AppendLine();
        aggregatedContent.Append("// Taken from File: ");
        aggregatedContent.AppendLine(currentFileUrl);
        aggregatedContent.AppendLine();

        bool withinConditionalT4IfBlock = false;
        bool withinConditionalT4ElseBlock = false;
        bool beforeNamespace = true;

        while (currentLine != null) {
          if (withinConditionalT4IfBlock && currentLine.StartsWith("#else")) {
            withinConditionalT4ElseBlock = true;
          } else if (withinConditionalT4IfBlock && currentLine.StartsWith("#endif")) {
            withinConditionalT4IfBlock = false;
            withinConditionalT4ElseBlock = false;
          } else if (currentLine.StartsWith("#if !UsedByT4")) {
            withinConditionalT4IfBlock = true;
          } else if (withinConditionalT4IfBlock && !withinConditionalT4ElseBlock) {
            // skip
          } else if (currentLine.StartsWith("[assembly:")) {
            // skip
          } else if (currentLine.StartsWith("using ")) {
            usings.Add(currentLine);
          } else if (currentLine.StartsWith("namespace ")) {
            beforeNamespace = false;
            aggregatedContent.AppendLine(currentLine);
          } else if (beforeNamespace && String.IsNullOrWhiteSpace(currentLine)) {
            // skip          
          } else {
            aggregatedContent.AppendLine(currentLine);
          }
          currentLine = reader.ReadLine();
        } // wend
      } // using TextReader
    } // next fileDownloadUrl
  } // using WebClient

  aggregatedContent = aggregatedContent.Replace("partial class ", "class ");
  aggregatedContent = aggregatedContent.Replace("public class ", "internal class ");
  aggregatedContent = aggregatedContent.Replace("public static class ", "\n  internal static class ");
  aggregatedContent = aggregatedContent.Replace("public interface ", "\n  internal interface ");
  aggregatedContent = aggregatedContent.Replace("public static interface ", "internal static interface ");
  aggregatedContent = aggregatedContent.Replace("public enum ", "internal enum ");
  aggregatedContent = aggregatedContent.Replace("class ", "partial class ");
  aggregatedContent = aggregatedContent.Replace("partial partial ", "partial ");

  // usings
  
  IEnumerable<string> sanitizedUsings = usings.Distinct().OrderBy((u)=>u);
  aggregatedContent.Insert(0, string.Join("\r\n", sanitizedUsings) + "\r\n");
  aggregatedContent.ToString();

  content = aggregatedContent.ToString();
} catch (Exception ex) {
  content = "Error Processing '" + currentFileUrl + "': " + ex.Message;
}
#><#= content #>
