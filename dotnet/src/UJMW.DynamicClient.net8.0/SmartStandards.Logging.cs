using Logging.SmartStandards.EventKindManagement;
using Logging.SmartStandards.Internal;
using Logging.SmartStandards.Textualization;
using Logging.SmartStandards.Transport;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System;

// This is a partial copy of the SmartStandards Logging Library.
// It is intended to be used as an alternative when including the NuGet package is not feasible.
// It offers reduced features: There is no custom routing, emitted log events always flow to the TraceBus.

// This file was generated by SmartStandards.Logging.tt v 2.1.0
// Included sources were downloaded from: https://github.com/SmartStandards/Logging

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Textualization/CopyOfPlaceholderExtensions .cs

namespace Logging.SmartStandards.Textualization {

  internal static partial class CopyOfPlaceholderExtensions { // v 1.0.0

    // Inner partial class content manually copied from:
    // https://github.com/SmartStandards/Essentials/blob/master/dotnet/src/SmartStandards.Essentials/System/SmartStandards/PlaceholderExtensions.cs

    /// <summary>
    ///   Executes a callback method for each placeholder in a template string.
    /// </summary>
    /// <param name="extendee">
    ///   A template string containing named placeholders. 
    ///   E.g. "Hello {audience}, the answer is {answer}."
    /// </param>
    /// <param name="onPlaceholderFound">
    ///   bool onPlaceholderFound(string placeholderName).
    ///   Will be called for each placeholder in order of appearance.
    ///   (e.g. "audience", "answer").
    ///   The placeholder name will be passed (without braces), unless omitPlaceholderNames is set (then null will be passed).
    ///   If the callback function returns true (= cancel), the processing will stop immedieately.
    /// </param>
    /// <param name="onRegularSegmentFound">
    ///   void onRegularSegmentFound(int pos, int length).
    ///   Optional. Will be called for each seqgment of the template that is not a placeholder.
    ///   (e.g. "Hello ", ", the answer is ", ".").
    /// </param>
    /// <param name="omitPlaceholderNames">
    ///   Performance optimization. If true, the placeholder name is not extracted from the template.
    /// </param>
    public static void ForEachPlaceholder(
      this string extendee,
      Func<string, bool> onPlaceholderFound,
      Action<int, int> onRegularSegmentFound = null,
      bool omitPlaceholderNames = false
    ) {

      if (extendee is null || extendee.Length < 3) return;

      int cursor = 0;

      do {

        int leftPos = extendee.IndexOf("{", cursor);

        if (leftPos < 0) break;

        int rightPos = extendee.IndexOf("}", cursor);

        if (rightPos < 0 || rightPos < leftPos + 1) return;

        string placeholderName = null;

        if (!omitPlaceholderNames) placeholderName = extendee.Substring(leftPos + 1, rightPos - leftPos - 1);

        onRegularSegmentFound?.Invoke(cursor, leftPos - cursor);

        if (onPlaceholderFound.Invoke(placeholderName)) return;

        cursor = rightPos + 1;

      } while (cursor < extendee.Length);

      onRegularSegmentFound?.Invoke(cursor, extendee.Length - cursor);
    }

    /// <summary>
    ///   Resolves named placeholders in a template string from arguments.
    /// </summary>
    /// <param name="extendee">
    ///   A template string containing named placeholders. 
    ///   E.g. "Hello {audience}, the answer is {answer}."
    /// </param>
    /// <param name="args">
    ///   Arguments containing the placeholder values in order of appearance in the template. Example:
    ///   "World", 42
    /// </param>
    /// <returns>
    ///   Null or a new string instance with resolved placeholders. The example would be resolved to:
    ///   "Hello World, the answer is 42."
    /// </returns>
    public static string ResolvePlaceholders(this string extendee, params object[] args) {

      int maxIndex = args != null ? args.GetUpperBound(0) : -1;

      if (extendee is null || extendee.Length < 3 || maxIndex < 0) return extendee;

      StringBuilder targetStringBuilder = new StringBuilder(extendee.Length * 15 / 10);

      targetStringBuilder.AppendResolved(extendee, args);

      return targetStringBuilder.ToString();
    }

    /// <summary>
    ///   Resolves placeholders within a StringBuilder instance.
    /// </summary>
    /// <param name="extendee"> The StringBuilder instance containing unresolved placeholders. </param>
    /// <param name="args"> Placeholder values in correct order. </param>
    /// <returns> The StringBuilder instance after resolvingvar (to support fluent syntax). </returns>
    /// <remarks>
    ///   The internal behavior of this method is NOT equivalent to the same named string extension.
    ///   Is is NOT performant to convert a string to a StringBuilder and pass it to this extension.
    ///   Only use this extension if you have a StringBuilder instance anyways and you want to keep the instance.
    ///   Otherwise using the string extension is faster.
    /// </remarks>
    public static StringBuilder ResolvePlaceholders(this StringBuilder extendee, params object[] args) {

      if (extendee == null || args == null) { return extendee; }

      if (args.Length == 0) { return extendee; }

      int cursor = 0;

      foreach (object boxedValue in args) {

        int left = -1;

        for (int i = cursor; i < extendee.Length; i++) {
          if (extendee[i] == '{') { left = i; break; }
          ;
        }

        if (left == -1) { break; }

        int right = -1;

        for (int i = left; i < extendee.Length; i++) {
          if (extendee[i] == '}') { right = i; break; }
          ;
        }

        if (right == -1) { break; }

        extendee.Remove(left, right - left + 1);

        string value = boxedValue.ToString();

        extendee.Insert(left, value);

        cursor += value.Length;
      }

      return extendee;
    }

    public static string ResolvePlaceholdersByDictionary(this string extendee, IDictionary<string, object> placeholders) {

      if (extendee is null || extendee.Length < 3 || placeholders is null || placeholders.Count == 0) {
        return extendee;
      }

      object onResolvePlaceholder(string placeholderName) {
        object value = null;
        if (placeholders.TryGetValue(placeholderName, out value)) {
          return value ?? ""; // Value is null => render empty string
        } else {
          return null; // Value not existing => return null => leave placeholder unchanged
        }
      }

      StringBuilder targetStringBuilder = new StringBuilder(extendee.Length * 15 / 10);

      targetStringBuilder.AppendResolving(extendee, onResolvePlaceholder);

      return targetStringBuilder.ToString();
    }

    public static string ResolvePlaceholdersByPropertyBag(this string extendee, object propertyBag) {

      if (extendee is null || extendee.Length < 3 || propertyBag is null) return extendee;

      object onResolvePlaceholder(string placeholderName) {

        PropertyInfo propertyInfo = propertyBag.GetType().GetProperty(
          placeholderName, BindingFlags.Public | BindingFlags.IgnoreCase | BindingFlags.Instance
        );

        if (propertyInfo != null) {
          return propertyInfo.GetValue(propertyBag) ?? ""; // Property value is null => render empty string
        } else {
          return null; // Property not existing => return null => leave placeholder unchanged
        }
      }

      StringBuilder targetStringBuilder = new StringBuilder(extendee.Length * 15 / 10);

      targetStringBuilder.AppendResolving(extendee, onResolvePlaceholder);

      return targetStringBuilder.ToString();
    }

    /// <summary>
    ///   Appends a resolved template string to an existing StringBuilder while calling back a resolving method for each placeholder.
    /// </summary>
    /// <param name="template"> A template string containing named placeholders. E.g. "Hello {audience}, the answer is {answer}."</param>
    /// <param name="onResolvePlaceholder">
    ///   string onResolvePlaceholder(name).
    ///   Will be called for each placeholder in order of appearance.
    ///   (e.g. "audience", "answer").
    ///   The placeholder name will be passed (or null, if omitPlaceholderNames is set).
    ///   The resolved placeholder value should be returned 
    ///   (Note: if the template contains a format-string siffix like ':yyyy-MM-dd', it is important, that the resolved placeholder value was not already converted into a string during resolving!). 
    ///   If null is returned, the placeholder will remain unchanged (including braces).
    ///   </param>
    /// <param name="omitPlaceholderNames">
    ///   Performance optimization. If true, the placeholder name is not extracted from the template.
    /// </param>
    /// <returns> The resolved string. </returns>
    public static StringBuilder AppendResolving(
      this StringBuilder extendee,
      string template,
      Func<string, object> onResolvePlaceholder,
      bool omitPlaceholderNames = false
    ) {

      if (extendee == null) return null;

      if (template is null || template.Length < 3 || onResolvePlaceholder is null) {
        extendee.Append(template);
        return extendee;
      }

      bool onPlaceholderFound(string placeholderNameOrExpression) {

        string valueAsString = null;

        if(placeholderNameOrExpression != null) {
          int formatStringSeparatorIndex = placeholderNameOrExpression.IndexOf(':');
          if (formatStringSeparatorIndex < 0) {
            valueAsString = onResolvePlaceholder.Invoke(placeholderNameOrExpression)?.ToString();
          }
          else {
            object value = onResolvePlaceholder.Invoke(placeholderNameOrExpression.Substring(0, formatStringSeparatorIndex));
            if(value != null) {
              string formatString = placeholderNameOrExpression.Substring(formatStringSeparatorIndex + 1);
              valueAsString = string.Format("{0:" + formatString + "}", value);
            }
          }
        }
        else {
          valueAsString = onResolvePlaceholder.Invoke(null)?.ToString();
        }

        if (valueAsString != null) {
          extendee.Append(valueAsString);
        } else {
          extendee.Append('{').Append(placeholderNameOrExpression).Append('}');
        }
        return false;
      }

      void onRegularSegmentFound(int pos, int length) => extendee.Append(template, pos, length);

      template.ForEachPlaceholder(onPlaceholderFound, onRegularSegmentFound, omitPlaceholderNames);

      return extendee;
    }

    public static StringBuilder AppendResolved(this StringBuilder extendee, string template, params object[] args) {

      if (extendee == null) return null;

      int maxIndex = args != null ? args.GetUpperBound(0) : -1;

      if (template is null || template.Length < 3 || maxIndex < 0) {
        extendee.Append(template);
        return extendee;
      }

      int i = -1;

      object onResolvePlaceholder(string dummyName) {
        i++;
        if (i <= maxIndex) {
          return args[i];
        } else {
          return null;
        }
      }

      extendee.AppendResolving(template, onResolvePlaceholder, true);

      return extendee;
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Textualization/LogParaphRenderer.Minimum.cs

namespace Logging.SmartStandards.Textualization {

  // This is the minimum portion of LogParaphRenderer (which is included by SmartStandards.Logging.tt)

  internal partial class LogParaphRenderer { // v 1.0.0

    public static string LevelToAlpha3(int level, StringBuilder targetStringBuilder = null) {

      switch (level) {

        case 5: { // Critical
          targetStringBuilder?.Append("Cri");
          return "Cri";
        }
        case 4: { // Error
          targetStringBuilder?.Append("Err");
          return "Err";
        }
        case 3: { // Warning
          targetStringBuilder?.Append("Wrn");
          return "Wrn";
        }
        case 2: { // Information
          targetStringBuilder?.Append("Inf");
          return "Inf";
        }
        case 1: { // Debug
          targetStringBuilder?.Append("Dbg");
          return "Dbg";
        }
        default: { // Trace
          targetStringBuilder?.Append("Trc");
          return "Trc";
        }
      }
    }

    /// <summary>
    ///   Appends a ready-to-read log paraph (having resolved placeholders) to an existing StringBuilder instance.
    /// </summary>    
    /// <returns>
    ///   Example LogParaph:
    ///   [LevelAsAlpha3] SourceContext #eventKindId#  SourceLineId [AudienceToken]: MessageTemplate 
    ///   [Err] MyApp.exe #4711# 2070198253252296432 [Ins]: File not found on Disk! 
    /// </returns>
    public static StringBuilder BuildParaphResolved(
      StringBuilder targetStringBuilder,
      string audienceToken, int level, string sourceContext, long sourceLineId,
      int eventKindId, string messageTemplate, object[] args
    ) {

      LogParaphRenderer.BuildParaphLeftPart(targetStringBuilder, level, sourceContext, eventKindId);

      LogParaphRenderer.BuildParaphRightPart(targetStringBuilder, sourceLineId, audienceToken, null);

      targetStringBuilder.AppendResolved(messageTemplate, args);

      return targetStringBuilder;
    }

    /// <summary>
    ///   Renders the left part of a log paraph.
    /// </summary>
    /// <remarks>
    ///   The left part contains meta data that would normally be transported as arguments.
    /// </remarks>
    /// <returns>
    ///   S.th. like "[Err] MyApp.exe #4711#"
    /// </returns>
    public static StringBuilder BuildParaphLeftPart(
      StringBuilder targetStringBuilder, int level, string sourceContext, int eventKindId
    ) {
      targetStringBuilder.Append('[');
      LogParaphRenderer.LevelToAlpha3(level, targetStringBuilder);
      targetStringBuilder.Append("] ");
      targetStringBuilder.Append(sourceContext);
      targetStringBuilder.Append(" #");
      targetStringBuilder.Append(eventKindId);
      targetStringBuilder.Append('#');
      return targetStringBuilder;
    }

    /// <summary>
    ///   Renders the right part of a log paraph.
    /// </summary>
    /// <remarks>
    ///   The right part contains meta data that cannot be transported as arguments, because most logging APIs do not offer enough
    ///   parameters.
    /// </remarks>
    /// <returns>
    ///   S.th. like " 2070198253252296432 [Ins]: File not found on Disk! "
    /// </returns>
    public static StringBuilder BuildParaphRightPart(
      StringBuilder targetStringBuilder, long sourceLineId, string audienceToken, string messageTemplate
    ) {
      targetStringBuilder.Append(' ');
      targetStringBuilder.Append(sourceLineId);
      targetStringBuilder.Append(" [");
      targetStringBuilder.Append(audienceToken);
      targetStringBuilder.Append("]: ");
      targetStringBuilder.Append(messageTemplate);
      return targetStringBuilder;
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Textualization/ExceptionRenderer.cs

namespace Logging.SmartStandards {

  
  internal static partial class ExceptionRenderer {

    public static void AppendToStringBuilder(StringBuilder sb, Exception ex, bool includeStacktrace = true) {
      try {
        int messageCursor = 0;
        AppendRecursive(ex, sb, ref messageCursor, includeStacktrace);
      } catch (Exception ex2) {
        sb.Append(ex2);
      }
    }

    /// <summary>
    ///   Serializes an Exception in a way, that InnerExceptions and StackTraces are included
    ///   and returns a message string, which is highly optimized for logging requirements.
    /// </summary>
    public static string Render(Exception ex, bool includeStacktrace = true) {
      StringBuilder sb = new StringBuilder(1000);
      AppendToStringBuilder(sb, ex, includeStacktrace);
      return sb.ToString();
    }

    private static void AppendRecursive(
      Exception ex, StringBuilder target, ref int messageCursor, bool includeStackTrace, bool isInner = false
    ) {

      if (ex == null) {
        return;
      }

      if (isInner) {
        target.Insert(messageCursor, " :: ");
        messageCursor += 4;
      }

      target.Insert(messageCursor, ex.Message);
      messageCursor += ex.Message.Length;

      if (!isInner) target.Insert(messageCursor, Environment.NewLine);

      target.AppendLine($"-- {ex.GetType().FullName} --");

      string originalStackTrace = ex.StackTrace;

      if (includeStackTrace && !string.IsNullOrWhiteSpace(originalStackTrace)) {

        int cursor = originalStackTrace.Length;
        int lineStartIndex = 0;
        int lineEndIndex = originalStackTrace.Length;

        while (cursor > 0) {
          cursor = originalStackTrace.LastIndexOf(Environment.NewLine, cursor);
          if (cursor < 0) {
            lineStartIndex = 0;
          } else {
            lineStartIndex = cursor + Environment.NewLine.Length;
          }

          // split member / file

          // " in C:\..."
          int fileSegmentStartIndex = originalStackTrace.IndexOf(" in ", lineStartIndex, lineEndIndex - lineStartIndex);

          if (fileSegmentStartIndex >= 0) fileSegmentStartIndex += 4;

          int fileSegmentEndIndex = lineEndIndex;

          // "   at MyNamespace..."
          int memberSegmentStartIndex = lineStartIndex;

          if (originalStackTrace.IndexOf(" at ", lineStartIndex) >= 0) {
            memberSegmentStartIndex = lineStartIndex + 6;
          } else if (originalStackTrace.IndexOf(" bei ", lineStartIndex) >= 0) {
            memberSegmentStartIndex = lineStartIndex + 7;
          }

          int memberSegmentEndIndex = (fileSegmentStartIndex >= 0) ? fileSegmentStartIndex - 4 : lineEndIndex;

          if (memberSegmentStartIndex < memberSegmentEndIndex) {
            target.Append("@ ");
            target.Append(originalStackTrace, memberSegmentStartIndex, memberSegmentEndIndex - memberSegmentStartIndex);
            target.AppendLine();

            if (fileSegmentStartIndex >= 0) {
              target.Append("@   ");
              target.Append(originalStackTrace, fileSegmentStartIndex, fileSegmentEndIndex - fileSegmentStartIndex);
              target.AppendLine();
            }
          }

          lineEndIndex = cursor;
        }

      }

      if ((ex.InnerException != null)) {
        AppendRecursive(ex.InnerException, target, ref messageCursor, includeStackTrace, true);
      }

    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Transport/TraceBusFeed.cs

namespace Logging.SmartStandards.Transport {

  /// <summary>
  ///   Helper partial class for emitting messages into the (legacy) .NET System.Diagnostics.Trace concept
  /// </summary>
  internal partial class TraceBusFeed { // v 2.0.0

    private MyCircularBuffer<QueuedEvent> _DebuggingLookBackBuffer;

    private static TraceBusFeed _Instance;

    public static TraceBusFeed Instance {
      get {

        if (_Instance == null) {
          _Instance = new TraceBusFeed();
        }

        return _Instance;
      }
    }

    public List<string> RawModeListeners { get; set; } = new List<string>() { "SmartStandards395316649" };

    public HashSet<string> IgnoredListeners { get; set; } = new HashSet<string>();

    public bool AutoFlush { get; set; } = true;

    private void FlushAndShutDownBuffer(TraceListener targetListener) {

      if (_DebuggingLookBackBuffer == null) return;

      lock (this) {

        _DebuggingLookBackBuffer.StopAutoFlush();

        foreach (QueuedEvent e in _DebuggingLookBackBuffer) {
          this.InvokeListener(targetListener, e.Audience, e.Level, e.SourceContext, e.SourceLineId, e.EventKindId, e.MessageTemplate, e.Args);
        }

        _DebuggingLookBackBuffer = null;
      }
    }

    /// <summary>
    ///   Helper to invoke the TraceEvent() method of a TraceListener the right way.
    ///   Identify the right overload and respect thread safety.
    /// </summary>
    private void InvokeListenerTraceEvent(
      TraceListener targetListener, TraceEventCache eventCache, TraceEventType eventType, string sourceContext, int id, string format, params object[] args
    ) {
      if (targetListener.IsThreadSafe) {
        if (args == null) {
          targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format);
          if (this.AutoFlush) targetListener.Flush();
        } else {
          targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format, args);
          if (this.AutoFlush) targetListener.Flush();
        }
      } else {
        lock (targetListener) {
          if (args == null) {
            targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format);
            if (this.AutoFlush) targetListener.Flush();
          } else {
            targetListener.TraceEvent(eventCache, sourceContext, eventType, id, format, args);
            if (this.AutoFlush) targetListener.Flush();
          }
        }
      }
    }

    private void InvokeListenerWriteLine(TraceListener targetListener, string text) {
      if (targetListener.IsThreadSafe) {
        targetListener.WriteLine(text);
        if (this.AutoFlush) targetListener.Flush();
      } else {
        lock (targetListener) {
          targetListener.WriteLine(text);
        }
      }
    }

    /// <param name="targetListener"> If null, invoke all listeners. </param>
    private void InvokeListener(
      TraceListener targetListener,
      string audience, int level, string sourceContext, long sourceLineId,
      int eventKindId, string messageTemplate, params object[] args
    ) {

      StringBuilder logParaphBuilder = null;

      TraceEventCache eventCache = null;
      TraceEventType eventType = TraceEventType.Verbose;
      StringBuilder rightPartOnlyBuilder = null;

      // Lazily create stuff that is needed only in case we need to pass the log event as presentation-ready

      Action onPreparePresentationReadyStuff = () => {
        if (logParaphBuilder == null) {
          logParaphBuilder = new StringBuilder(messageTemplate.Length + 20);
          if (args.Length > 0 && args[0] is Exception) {
            ExceptionRenderer.AppendToStringBuilder(logParaphBuilder, (Exception)args[0]);
          } else {
            LogParaphRenderer.BuildParaphResolved(
              logParaphBuilder, audience, level, sourceContext, sourceLineId, eventKindId, messageTemplate, args
            );
          }
        }
      };

      // Lazily create stuff that is needed only in case we need to pass the log event as trace event

      Action onPrepareTraceEventStuff = () => {
        if (eventCache == null) {
          eventCache = new TraceEventCache(); // same instance for many listeners
          eventType = LevelToTraceEventType(level);

          rightPartOnlyBuilder = new StringBuilder(messageTemplate.Length + 20);
          LogParaphRenderer.BuildParaphRightPart(rightPartOnlyBuilder, sourceLineId, audience, messageTemplate);
          rightPartOnlyBuilder.Replace("{", "{{").Replace("}", "}}");
        }
      };

      // This is the inner snippet, actually invoking a listener

      Action<TraceListener> onInvokeListener = (TraceListener listener) => {
        bool useRawMode = this.RawModeListeners.Contains(listener.Name);
        if (useRawMode) {
          onPrepareTraceEventStuff.Invoke();
          this.InvokeListenerTraceEvent(listener, eventCache, eventType, sourceContext, eventKindId, rightPartOnlyBuilder.ToString(), args);
        } else {
          onPreparePresentationReadyStuff.Invoke();
          this.InvokeListenerWriteLine(listener, logParaphBuilder.ToString());
        }
      };

      // this is the outer loop

      if (targetListener != null) { // invoke only one specific listener

        onInvokeListener(targetListener);

      } else { // no specific listener -> invok all (relevant) listeners

        this.ForEachRelevantListener(
          (TraceListener listener) => { onInvokeListener(listener); }
        );
      }
    }

    public void EmitException(string audience, int level, string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      this.EmitMessage(audience, level, sourceContext, sourceLineId, eventKindId, ex.Message, new object[] { ex });
    }

    private DefaultTraceListener ForEachRelevantListener(Action<TraceListener> onProcessListener) {

      DefaultTraceListener foundDefaultTraceListener = null;

      foreach (TraceListener listener in Trace.Listeners) {

        if (this.IgnoredListeners.Contains(listener.Name)) continue;

        DefaultTraceListener defaultTraceListener = listener as DefaultTraceListener; // try cast

        if (defaultTraceListener != null) {

          bool isLogging = Debugger.IsLogging();

          foundDefaultTraceListener = defaultTraceListener;

          if (_DebuggingLookBackBuffer != null && isLogging) this.FlushAndShutDownBuffer(defaultTraceListener);

          // Is the default logger EmittingWorthy?
          if (!isLogging && String.IsNullOrWhiteSpace(defaultTraceListener.LogFileName)) continue;
        }

        onProcessListener.Invoke(listener);

      }
      return foundDefaultTraceListener;
    }

    /// <param name="level">
    ///   5 Critical
    ///   4 Error
    ///   3 Warning
    ///   2 Info
    ///   1 Debug
    ///   0 Trace
    /// </param>
    public void EmitMessage(
      string audience, int level, string sourceContext, long sourceLineId,
      int eventKindId, string messageTemplate, params object[] args
    ) {

      // Performance: Do not prepare a message that is never sent (or buffered)

      bool emittingWorthyListenersExist = false;

      DefaultTraceListener foundDefaultTraceListener = null;

      foundDefaultTraceListener = this.ForEachRelevantListener((TraceListener listener) => { emittingWorthyListenersExist = true; });

      if (!Debugger.IsLogging() && foundDefaultTraceListener != null && _DebuggingLookBackBuffer == null) {

        _DebuggingLookBackBuffer = new MyCircularBuffer<QueuedEvent>(1000);

        _DebuggingLookBackBuffer.StartAutoFlush(() => { if (Debugger.IsLogging()) this.FlushAndShutDownBuffer(foundDefaultTraceListener); }, 3000);
      }

      if (!emittingWorthyListenersExist && _DebuggingLookBackBuffer == null) return;

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (string.IsNullOrWhiteSpace(audience)) audience = "Dev";

      if (messageTemplate == null) messageTemplate = "";

      // actual emit

      this.InvokeListener(null, audience, level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);

      if (_DebuggingLookBackBuffer != null) {
        lock (this) {
          _DebuggingLookBackBuffer.UnsafeEnqueue(new QueuedEvent(audience, level, sourceContext, sourceLineId, eventKindId, messageTemplate, args));
        }
      }

    }

    private static TraceEventType LevelToTraceEventType(int level) {
      switch (level) {
        case 5: return TraceEventType.Critical; // 1 Critical (aka "Fatal")
        case 4: return TraceEventType.Error; // 2
        case 3: return TraceEventType.Warning; // 4
        case 2: return TraceEventType.Information; // 8
        case 1: return TraceEventType.Transfer; // 4096 - ' There is no "Debug" EventType => use something else                
        default: return TraceEventType.Verbose; // 16 "Trace"
      }
    }

  }

  internal partial class QueuedEvent {

    public string Audience { get; set; }

    public int Level { get; set; }

    public string SourceContext { get; set; }

    public long SourceLineId { get; set; }

    public int EventKindId { get; set; }

    public string MessageTemplate { get; set; }

    public object[] Args { get; set; }

    public QueuedEvent(
      string audience, int level, string sourceContext, long sourceLineId,
      int eventKindId, string messageTemplate, params object[] args
    ) {
      this.Audience = audience;
      this.Level = level;
      this.SourceContext = sourceContext;
      this.SourceLineId = sourceLineId;
      this.EventKindId = eventKindId;
      this.MessageTemplate = messageTemplate;
      this.Args = args;
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Transport/TraceBusFeed.Buffer.cs

namespace Logging.SmartStandards.Transport {

  internal partial class TraceBusFeed {

    /// <remarks>
    ///   Taken from https://stackoverflow.com/a/5924776
    /// </remarks>
    internal partial class MyCircularBuffer<T> : IEnumerable<T> { // v 1.0.0

      readonly int _Size;

      readonly object _Locker;

      int _Count;
      int _Head;
      int _Rear;
      T[] _Values;

      public MyCircularBuffer(int max) {
        _Size = max;
        _Locker = new object();
        _Count = 0;
        _Head = 0;
        _Rear = 0;
        _Values = new T[_Size];
      }

      static int Incr(int index, int size) {
        return (index + 1) % size;
      }

      public object SyncRoot { get { return _Locker; } }

      public void SafeEnqueue(T obj) {
        lock (_Locker) { this.UnsafeEnqueue(obj); }
      }

      public void UnsafeEnqueue(T obj) {

        _Values[_Rear] = obj;

        if (_Count == _Size) _Head = Incr(_Head, _Size);

        _Rear = Incr(_Rear, _Size);
        _Count = Math.Min(_Count + 1, _Size);
      }

      public IEnumerator<T> GetEnumerator() {
        int index = _Head;

        for (int i = 0; i < _Count; i++) {
          yield return _Values[index];
          index = Incr(index, _Size);
        }

      }

      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
        return this.GetEnumerator();
      }

      CancellationTokenSource _CancellationTokenSource = null;

      Action _OnFlush;

      public void StartAutoFlush(Action onFlush, int interval) {

        if (_CancellationTokenSource != null) return;

        _OnFlush = onFlush;

        _CancellationTokenSource = new CancellationTokenSource();

        CancellationToken ct = _CancellationTokenSource.Token;

        Task.Run(() => this.AutoFlushInfiniteLoop(interval, ct));
      }

      private void AutoFlushInfiniteLoop(int interval, CancellationToken ct) {
        while (!ct.IsCancellationRequested) {
          Thread.Sleep(interval);
          lock (_Locker) {
            _OnFlush.Invoke();
          }
        }
      }

      public void StopAutoFlush() {
        if (_CancellationTokenSource == null) return;
        _CancellationTokenSource.Cancel();
        _CancellationTokenSource.Dispose();
        _CancellationTokenSource = null;
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Internal/ExceptionAnalyzer.cs

namespace Logging.SmartStandards.Internal {

  internal partial class ExceptionAnalyzer { // v 1.0.0

    internal static int InferEventKindIdByException(Exception ex) {

      // 'Zwiebel' durch Aufrufe via Reflection (InnerException ist mehr repräsentativ)

      if (ex is TargetInvocationException && ex.InnerException != null) {
        return InferEventKindIdByException(ex.InnerException);
      }

      // 'Zwiebel' durch Task.Run (InnerException ist mehr repräsentativ)

      if (ex is AggregateException) {
        AggregateException castedAggregateException = (AggregateException)ex;
        if (
          castedAggregateException.InnerExceptions != null &&
          castedAggregateException.InnerExceptions.Count == 1 //falls nur 1 enthalten (macht MS gern)
        ) {
          return InferEventKindIdByException(castedAggregateException.InnerExceptions[0]);
        }
      }

      // An einer Win32Exception hängt i.d.R. bereits eine eventKindId => diese verwenden

      if (ex is Win32Exception) {
        return ((Win32Exception)ex).NativeErrorCode;
      }

      // Falls der Absender die Konvention "MessageText #{eventKindId}" einhielt...

      int hashTagIndex = ex.Message.LastIndexOf('#');

      if (hashTagIndex >= 0 && int.TryParse(ex.Message.Substring(hashTagIndex + 1), out int id)) {
        return id;
      }

      // 'Zwiebel' durch Exception.Wrap (InnerException ist mehr repräsentativ)

      if (ex is ConcretizedException) {
        return InferEventKindIdByException(ex.InnerException);
      }

      // Fallback zuletzt: Wir leiten aus dem Exception-Typ eine eventKindId ab.

      using (var md5 = MD5.Create()) {
        int hash = BitConverter.ToInt32(md5.ComputeHash(Encoding.UTF8.GetBytes(ex.GetType().Name)), 0);
        if (hash < 0) {
          return hash * -1;
        }
        return hash;
      }

    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/Internal/SourceContextDiscoverer.cs

namespace Logging.SmartStandards.Internal {

  internal partial class SourceContextDiscoverer { // v 1.0.0

    private static Dictionary<Assembly, String> _SourceContextNamesByAssembly = new Dictionary<Assembly, String>();

    /// <summary>
    ///   Searches for [assembly: AssemblyMetadata("SourceContext", "CustomSourceContextName")]
    /// </summary>
    /// <returns> S.th. like "CustomSourceContextName" </returns>
    internal static string InferSourceContext(Assembly candidateAssembly) {

      lock (_SourceContextNamesByAssembly) {

        string sourceContextName;

        if (_SourceContextNamesByAssembly.TryGetValue(candidateAssembly, out sourceContextName)) {
          return sourceContextName;
        }

        AssemblyMetadataAttribute foundAttribute = candidateAssembly.GetCustomAttributes<AssemblyMetadataAttribute>()?.Where(
          (AssemblyMetadataAttribute a) => a.Key.Equals("SourceContext", StringComparison.CurrentCultureIgnoreCase)
        ).FirstOrDefault();

        if (foundAttribute != null) {
          sourceContextName = foundAttribute.Value;
        } else {
          sourceContextName = candidateAssembly.GetName().Name;
        }

        _SourceContextNamesByAssembly[candidateAssembly] = sourceContextName;

        return sourceContextName;
      }

    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/BizLogger.cs

namespace Logging.SmartStandards {

  internal partial class BizLogger {

    public const string AudienceToken = "Biz";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(
      int level, string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args
    ) {
      EventKindRepository.GetKindIdAndMessageTemplateByEnum(eventKindEnumElement, out int eventKindId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {

      int eventKindId = ExceptionAnalyzer.InferEventKindIdByException(ex);

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

    public static void Log(int level, string sourceContext, long sourceLineId, int eventKindId, Exception ex) {

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/BizLogger.PerLevel.cs

namespace Logging.SmartStandards {

  internal partial class BizLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(0, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(1, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(2, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(3, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(4, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(5, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/BizLogger.WoSourceContext.cs

namespace Logging.SmartStandards {

  internal partial class BizLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region eventKindEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, eventKindEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region SourceLineId and eventKindId and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    #endregion

    #region SourceLineId and EventKindEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    #endregion

    #region SourceLineId and eventKindId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.cs

namespace Logging.SmartStandards {

  internal partial class DevLogger {

    public const string AudienceToken = "Dev";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(
      int level, string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args
    ) {
      EventKindRepository.GetKindIdAndMessageTemplateByEnum(eventKindEnumElement, out int eventKindId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {

      int eventKindId = ExceptionAnalyzer.InferEventKindIdByException(ex);

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

    public static void Log(int level, string sourceContext, long sourceLineId, int eventKindId, Exception ex) {

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.PerLevel.cs

namespace Logging.SmartStandards {

  internal partial class DevLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(0, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(1, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(2, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(3, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(4, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(5, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/DevLogger.WoSourceContext.cs

namespace Logging.SmartStandards {

  internal partial class DevLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region eventKindEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, eventKindEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region SourceLineId and EventKindId and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    #endregion

    #region SourceLineId and EventKindEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    #endregion

    #region SourceLineId and EventKindId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/InsLogger.cs

namespace Logging.SmartStandards {

  internal partial class InsLogger {

    public const string AudienceToken = "Ins";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(
      int level, string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args
    ) {
      EventKindRepository.GetKindIdAndMessageTemplateByEnum(eventKindEnumElement, out int eventKindId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {

      int eventKindId = ExceptionAnalyzer.InferEventKindIdByException(ex);

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

    public static void Log(int level, string sourceContext, long sourceLineId, int eventKindId, Exception ex) {

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/InsLogger.PerLevel.cs

namespace Logging.SmartStandards {

  internal partial class InsLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(0, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(1, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(2, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(3, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(4, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(5, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/InsLogger.WoSourceContext.cs

namespace Logging.SmartStandards {

  internal partial class InsLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region eventKindEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, eventKindEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region SourceLineId and EventKindId and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    #endregion

    #region SourceLineId and EventKindEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    #endregion

    #region SourceLineId and eventKindId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/SecLogger.cs

namespace Logging.SmartStandards {

  internal partial class SecLogger {

    public const string AudienceToken = "Sec";

    public static void Log(
      int level, string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args
    ) {

      if (string.IsNullOrWhiteSpace(sourceContext)) sourceContext = "UnknownSourceContext";

      if (messageTemplate == null) messageTemplate = "";

      if (args == null) args = new object[0];

      TraceBusFeed.Instance.EmitMessage(AudienceToken, level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(
      int level, string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args
    ) {
      EventKindRepository.GetKindIdAndMessageTemplateByEnum(eventKindEnumElement, out int eventKindId, out string messageTemplate);
      Log(level, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void Log(int level, string sourceContext, long sourceLineId, Exception ex) {

      int eventKindId = ExceptionAnalyzer.InferEventKindIdByException(ex);

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

    public static void Log(int level, string sourceContext, long sourceLineId, int eventKindId, Exception ex) {

      TraceBusFeed.Instance.EmitException(AudienceToken, level, sourceContext, sourceLineId, eventKindId, ex); 
    }

  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/SecLogger.PerLevel.cs

namespace Logging.SmartStandards {

  internal partial class SecLogger {

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(0, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(0, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogTrace(string sourceContext, long sourceLineId, Exception ex) {
      Log(0, sourceContext, sourceLineId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(1, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(1, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogDebug(string sourceContext, long sourceLineId, Exception ex) {
      Log(1, sourceContext, sourceLineId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(2, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(2, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogInformation(string sourceContext, long sourceLineId, Exception ex) {
      Log(2, sourceContext, sourceLineId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(3, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(3, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogWarning(string sourceContext, long sourceLineId, Exception ex) {
      Log(3, sourceContext, sourceLineId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(4, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogError(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(4, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogError(string sourceContext, long sourceLineId, Exception ex) {
      Log(4, sourceContext, sourceLineId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      Log(5, sourceContext, sourceLineId, eventKindEnumElement, args);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, int eventKindId, Exception ex) {
      Log(5, sourceContext, sourceLineId, eventKindId, ex);
    }

    public static void LogCritical(string sourceContext, long sourceLineId, Exception ex) {
      Log(5, sourceContext, sourceLineId, ex);
    }
  }
}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/SecLogger.WoSourceContext.cs

namespace Logging.SmartStandards {

  internal partial class SecLogger {

    // NOTE: [MethodImpl(MethodImplOptions.NoInlining)]
    // is used to avoid wrong results from Assembly.GetCallingAssembly()

    #region MessageTemplate only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, 0, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, 0, messageTemplate, args);
    }

    #endregion

    #region eventKindEnumElement only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, eventKindEnumElement, args);
    }

    #endregion

    #region Exception only

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogTrace(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogDebug(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogInformation(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogWarning(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogError(currentSourceContext, 0, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      LogCritical(currentSourceContext, 0, ex);
    }

    #endregion

    #region SourceLineId and EventKindId and MessageTemplate

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, string messageTemplate, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, messageTemplate, args);
    }

    #endregion

    #region SourceLineId and EventKindEnumElement

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Enum eventKindEnumElement, params object[] args) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindEnumElement, args);
    }

    #endregion

    #region SourceLineId and EventKindId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, int eventKindId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, eventKindId, ex);
    }

    #endregion

    #region SourceLineId and Exception

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogTrace(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(0, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogDebug(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(1, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogInformation(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(2, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogWarning(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(3, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogError(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(4, currentSourceContext, sourceLineId, ex);
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    public static void LogCritical(long sourceLineId, Exception ex) {
      string currentSourceContext = SourceContextDiscoverer.InferSourceContext(Assembly.GetCallingAssembly());
      Log(5, currentSourceContext, sourceLineId, ex);
    }

    #endregion

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/ExceptionExtensions.cs

namespace Logging.SmartStandards {

  
  internal static partial class ExceptionExtensions { // v 1.0.0

    /// <summary>
    ///   Puts your envelope exception around an exception coming from elsewhere.
    /// </summary>
    /// <param name="extendee"> The 3rd party exception (becoming the inner exception). </param>
    /// <param name="message"> Your message adding value to the 3rd party exception. </param>
    /// <returns> A new ConcretizedException instance containing the extendee as inner exception. </returns>
    /// <remarks>
    ///   Purpose: The 3rd party exception might be generic (like null reference, etc.) and thus not very helpful.
    ///   Add specific information (like IDs etc.) in to the envelope's message.
    /// </remarks>
    public static Exception Wrap(this Exception extendee, string message) { // REQ #395397931

      ConcretizedException concretizedException = new ConcretizedException(message, extendee);

      return concretizedException;
    }

    /// <summary>
    ///   Puts your envelope exception around an exception coming from elsewhere.
    /// </summary>
    /// <param name="extendee"> The 3rd party exception (becoming the inner exception). </param>
    /// <param name="eventKindId"> Will be added as #-suffix to the message (SmartStandards compliant parsable). </param>
    /// <param name="message"> Your message adding value to the 3rd party exception. </param>
    /// <returns> A new ConcretizedException instance containing the extendee as inner exception. </returns>
    /// <remarks>
    ///   Purpose: The 3rd party exception might be generic (like null reference, etc.) and thus not very helpful.
    ///   Add specific information (like IDs etc.) in to the envelope's message.
    /// </remarks>
    public static Exception Wrap(this Exception extendee, int eventKindId, string message) { // REQ #395397931

      ConcretizedException concretizedException = new ConcretizedException(message + " #" + eventKindId.ToString(), extendee);

      return concretizedException;
    }

  }

  internal partial class ConcretizedException : Exception {

    public ConcretizedException(string message, Exception inner) : base(message, inner) {
    }

    public override string StackTrace {
      get {
        // if our StackTrace is empty (because usually this Wrapper wasnt thrown, either logged directly),
        // return the InnerException's StackTrace.
        if (string.IsNullOrWhiteSpace(base.StackTrace)) {
          return InnerException.StackTrace;
        }
        return base.StackTrace;
      }
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/EventKindManagement/LogMessageTemplateAttribute.cs

namespace Logging.SmartStandards.EventKindManagement {

  /// <summary>
  ///   Defines a log message template per enum value (for EventKind enums).
  /// </summary>
  [AttributeUsage(AttributeTargets.Field, AllowMultiple = true, Inherited = true)]
  internal partial class LogMessageTemplateAttribute : Attribute { // v 1.0.0

    /// <summary>
    ///  Constructor.
    /// </summary>
    /// <param name="logMessageTemplate"></param>
    /// <param name="language"> ISO code like 'en-us' or 'de-de' </param>
    public LogMessageTemplateAttribute(string logMessageTemplate, string language = null) {
      this.LogMessageTemplate = logMessageTemplate;
      this.Language = language;
    }

    public string LogMessageTemplate { get; }

    public string Language { get; }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/EventKindManagement/EventKindEnumConverter.cs

namespace Logging.SmartStandards.EventKindManagement {

  internal partial class EventKindEnumConverter : EnumConverter { // v 1.0.0

    private Array _FlagValues;

    private bool _IsFlagEnum = false;

    private Dictionary<CultureInfo, Dictionary<string, object>> _CachesPerLanguage = new Dictionary<CultureInfo, Dictionary<string, object>>();

    public EventKindEnumConverter(Type enumType) : base(enumType) {
      if (enumType.GetCustomAttributes(typeof(FlagsAttribute), true).Any()) {
        _IsFlagEnum = true;
        _FlagValues = Enum.GetValues(enumType);
      }
    }

    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

      if (value is string) {
        object result;

        if (_IsFlagEnum) {
          result = this.GetMessageTemplateFromAttributeByEnumFlag(culture, (string)value);
        } else {
          result = this.GetMessageTemplateFromCache(culture, (string)value);
        }

        if (result == null) {
          if (value != null) {
            result = base.ConvertFrom(context, culture, value);
          }
        }

        return result;
      }

      return base.ConvertFrom(context, culture, value);
    }

    public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {

      // at system.xaml.dll

      if (context == null || !(context.GetType().FullName.Equals("System.Windows.Markup.IValueSerializerContext"))) {
        if ((value != null) && (destinationType.Equals(typeof(System.String)))) {
          object result;
          if ((_IsFlagEnum)) {
            result = this.GetMessageTemplateFromAttributeByEnumFlagValue(culture, value);
          } else {
            result = this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
          }
          return result;
        }
      }

      return base.ConvertTo(context, culture, value, destinationType);
    }

    public static string ConvertToString(Enum value) {
      if (value != null) {
        TypeConverter converter = TypeDescriptor.GetConverter(value.GetType());
        return converter.ConvertToString(value);
      }
      return string.Empty;
    }

    private object GetMessageTemplateFromAttributeByEnumFlag(CultureInfo culture, string text) {
      Dictionary<string, object> languageSpecificCache = this.GetLanguageSpecificCache(culture);
      string[] textValues = text.Split(',');
      ulong result = 0;

      foreach (string textValue in textValues) {
        object value = null;
        string trimmedTextValue = textValue.Trim();

        if ((!languageSpecificCache.TryGetValue(trimmedTextValue, out value)))
          return null;

        result = result | Convert.ToUInt32(value);
      }

      return Enum.ToObject(this.EnumType, result);
    }

    private Dictionary<string, object> GetLanguageSpecificCache(CultureInfo culture) {
      lock (_CachesPerLanguage) {
        Dictionary<string, object> result = null;
        if (culture == null) {
          culture = CultureInfo.CurrentCulture;
        }
        if (!_CachesPerLanguage.TryGetValue(culture, out result)) {
          result = new Dictionary<string, object>();
          foreach (var value in this.GetStandardValues()) {
            var text = this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
            if (text != null) {
              result.Add(text, value);
            }
          }
          _CachesPerLanguage.Add(culture, result);
        }
        return result;
      }
    }

    private object GetMessageTemplateFromCache(CultureInfo culture, string text) {
      Dictionary<string, object> languageSpecificCache = this.GetLanguageSpecificCache(culture);
      object result = null;
      languageSpecificCache.TryGetValue(text, out result);
      return result;
    }

    private string GetMessageTemplateFromAttributeByEnumValue(CultureInfo culture, object value) {

      if (value == null) {
        return string.Empty;
      }

      Type type = value.GetType();

      if (!type.IsEnum) {
        return value.ToString();
      }

      LogMessageTemplateAttribute[] attributes = this.GetEnumFieldAttributes<LogMessageTemplateAttribute>((Enum)value);

      LogMessageTemplateAttribute defaultAttribute = attributes.FirstOrDefault();

      foreach (LogMessageTemplateAttribute attribute in attributes) {
        if (string.IsNullOrEmpty(attribute.Language)) {
          defaultAttribute = attribute;
        } else if (attribute.Language.Equals(culture.Name, StringComparison.InvariantCultureIgnoreCase)) {
          return attribute.LogMessageTemplate;
        }
      }
      if (defaultAttribute != null) {
        return defaultAttribute.LogMessageTemplate;
      } else {
        return Enum.GetName(type, value);
      }
    }

    private string GetMessageTemplateFromAttributeByEnumFlagValue(CultureInfo culture, object value) {
      if (Enum.IsDefined(value.GetType(), value)) {
        return this.GetMessageTemplateFromAttributeByEnumValue(culture, value);
      }
      long lValue = Convert.ToInt32(value);
      string result = null;
      foreach (object flagValue in _FlagValues) {
        long lFlagValue = Convert.ToInt32(flagValue);
        if (this.CheckSingleBit(lFlagValue)) {
          if ((lFlagValue & lValue) == lFlagValue) {
            string valueText = this.GetMessageTemplateFromAttributeByEnumValue(culture, flagValue);
            if (result == null) {
              result = valueText;
            } else {
              result = string.Format("{0}+{1}", result, valueText);
            }
          }
        }
      }

      return result;
    }

    public static List<KeyValuePair<Enum, string>> GetValues(Type enumType) {
      return GetValues(enumType, CultureInfo.CurrentUICulture);
    }

    public static List<KeyValuePair<Enum, string>> GetValues(Type enumType, CultureInfo culture) {
      List<KeyValuePair<Enum, string>> result = new List<KeyValuePair<Enum, string>>();
      TypeConverter converter = TypeDescriptor.GetConverter(enumType);
      foreach (System.Enum value in Enum.GetValues(enumType)) {
        KeyValuePair<Enum, string> pair = new KeyValuePair<Enum, string>(
          value, converter.ConvertToString(null, culture, value)
        );
        result.Add(pair);
      }
      return result;
    }

    private bool CheckSingleBit(long value) {
      switch (value) {
        case 0: {
          return false;
        }
        case 1: {
          return true;
        }
      }
      return ((value & (value - 1)) == 0);
    }

    private TAttribute[] GetEnumFieldAttributes<TAttribute>(Enum enumValue) where TAttribute : Attribute {
      Type enumType = enumValue.GetType();
      string enumFieldName = Enum.GetName(enumType, enumValue);
      if ((enumFieldName == null))
        return new TAttribute[] { };
      else {
        FieldInfo enumField = enumType.GetField(enumFieldName);
        return enumField.GetCustomAttributes(false).OfType<TAttribute>().ToArray();
      }
    }

  }

}

// Taken from File: https://raw.githubusercontent.com/SmartStandards/Logging/refs/heads/master/dotnet/src/SmartStandards.Logging/Logging/SmartStandards/EventKindManagement/EventKindRepository.cs

namespace Logging.SmartStandards.EventKindManagement {

  
  internal static partial class EventKindRepository { // v 1.0.0

    internal static void GetKindIdAndMessageTemplateByEnum(Enum eventKindEnumElement, out int eventKindId, out string messageTemplate) {

      eventKindId = (int)(object)eventKindEnumElement;

      messageTemplate = null;

      try {
        TypeConverter typeConverter = TypeDescriptor.GetConverter(eventKindEnumElement);
        if (typeConverter != null && typeConverter.CanConvertTo(typeof(System.String))) {
          messageTemplate = typeConverter.ConvertToString(eventKindEnumElement);
        }
      } catch {
      }
      if (String.IsNullOrWhiteSpace(messageTemplate)) {
        messageTemplate = Enum.GetName(eventKindEnumElement.GetType(), eventKindEnumElement);
      }
    }

  }
}

